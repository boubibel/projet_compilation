Propositions de tests à ajouter (priorisés, avec snippet et justification)

tests/multi_return_assign.go — test positif pour affectation multiple depuis une fonction
But : vérifier la lecture simultanée de plusieurs valeurs retournées.
Snippet proposé :
Pourquoi : le repo a div1 mais ce test isole l'affectation multiple et la propagation aux variables locales via :=.
tests/shadowing.go — test sur ombrement (shadowing) et := comportement
But : vérifier que := crée une nouvelle variable quand il y a ombrement dans un bloc, et réutilise sinon.
Snippet :
Pourquoi : couvre les règles de portée (portée de bloc), utile pour le typechecker et générateur de symboles.
tests/for_cstyle.go — test pour forme C-style de for (si supportée)
But : vérifier parsing et comportement de for (init; cond; post) {}.
Snippet (à ajouter seulement si la grammaire supporte cette forme) :
Pourquoi : instr.go utilise la forme for (cond) {}, mais la forme avec init/cond/post n'est pas testée — important si votre langue la prend en charge.
tests/type_mismatch_error.go — test négatif: erreur de typage (doit échouer au typechecker)
But : s'assurer que le système détecte un passage d'argument avec type incorrect.
Snippet :
Pourquoi : valider la génération d'erreur du typechecker (utile pour tests unitaires de l'analyseur de types).
tests/return_arity_error.go — test négatif: mauvaise arité de retour
But : appeler une fonction qui retourne 2 valeurs mais l'affecter à une seule variable (ou inversement).
Snippet :
Pourquoi : couvre le contrôle d'alignement du nombre de valeurs retournées et d'affectation.
tests/nil_and_pointer.go — test positif pour nil et comparaisons de pointeurs
But : vérifier que nil est pris en charge et que la comparaison pointeur/nil fonctionne.
Snippet :
Pourquoi : complète div3 (qui teste new) en testant le cas nil et les comparaisons.
tests/logical_operators.go — test sur &&, || et court-circuit (si supportés)
But : vérifier opérateurs logiques et ordre d'évaluation.
Snippet :
Pourquoi : logique importante et souvent source d'erreur s'il manque priorité ou court-circuit.
tests/struct_literal_or_init.go — test de littéraux struct (si votre grammaire les supporte)
But : vérifier parsing d'un littéral de struct ou notation d'initialisation.
Snippet (à ajouter si syntaxe acceptée) :
Pourquoi : pratique courante et utile si vous voulez fournir des initialisateurs littéraux.
tests/redeclare_error.go — test négatif: redéclaration illégale
But : vérifier que redéclaration dans le même scope est interdite.
Snippet :
Pourquoi : couvre la vérification des symboles et détection d'erreurs de déclaration.
tests/multiple_assignments_and_swap.go — test sur affectations multiples et expressions complexes
But : vérifier a,b = b,a ou combos d'affectation multiple si votre langage les supporte.
Snippet :
Pourquoi : utile pour s'assurer que l'évaluation des r-values est faite avant l'affectation et que le tuple assign fonctionne.
Commandes recommandées pour tester localement

Construire :
Pour exécuter un test de parsing/typage avec votre utilitaire (exemples) :
(Adaptez le nom de l'exécutable s'il est différent; utilisez dune exec -- pour exécuter la cible construite.)

Souhaitez-vous que je :

A) crée automatiquement ces fichiers de test dans tests/ (je peux en ajouter 3 à la fois, ex. multi_return_assign.go, shadowing.go, type_mismatch_error.go), ou
B) que je génère un patch contenant tous les snippets pour que vous puissiez les valider avant ajout ?
Dites-moi votre préférence et j'ajoute les fichiers (ou seulement ceux que vous voulez).